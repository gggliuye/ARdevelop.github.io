<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Polygon Selector with Trajectory</title>
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
    <!-- Leaflet Draw CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css" />
    <style>
        #map {
            height: 70vh;
            width: 100%;
        }
        #controls {
            padding: 10px;
            font-family: Arial, sans-serif;
        }
        #output {
            padding: 10px;
            font-family: Arial, sans-serif;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <h1>Polygon Selector with Trajectory</h1>
    <div id="controls">
        <label for="resolution">Trajectory Resolution (meters):</label>
        <input type="number" id="resolution" value="20" min="1">
        <button onclick="clearMap()">Clear Map</button>
    </div>
    <div id="map"></div>
    <div id="output">Coordinates and trajectory details will be displayed here...</div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <!-- Leaflet Draw JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
    <script src="math/convex_hull.js"></script>
    <script>
        const map = L.map('map', {
            zoomSnap: 0.05,
            zoomDelta: 0.25,
            zoomAnimation: true,
            wheelPxPerZoomLevel: 120,
            minZoom: 3
        }).fitWorld();

        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 20,
            attribution: 'Â© OpenStreetMap contributors'
        }).addTo(map);

        map.locate({ setView: true, maxZoom: 16 });

        const drawnItems = new L.FeatureGroup();
        map.addLayer(drawnItems);

        const drawControl = new L.Control.Draw({
            draw: {
                rectangle: true,
                polygon: true,
                polyline: false,
                circle: false,
                circlemarker: false,
                marker: false
            },
            edit: {
                featureGroup: drawnItems
            }
        });
        map.addControl(drawControl);

        let trajectoryLayer = null;

        // Convert resolution in meters to degrees
        function metersToDegrees(meters) {
            return meters / 111320; // Approximation for 1 degree = ~111.32 km
        }

        function isPointInsidePolygen(point, hull) {
            let count = 0;
            const [px, py] = point;
            for (let i = 0, j = hull.length - 1; i < hull.length; j = i++) {
                const [x1, y1] = hull[j];
                const [x2, y2] = hull[i];

                if ((y1 <= py && y2 > py || y2 <= py && y1 > py) &&
                    (x1 < (px - x2) * (y1 - y2) / (py - y2) + x2)) {
                    count++;
                }
            }
            return count % 2 !== 0; // If count is odd, the point is inside the hull
        }

        // Generate trajectory with 90-degree turns (scanning the area)
        function createTrajectory(polygonCoords, resolutionMeters) {
            const resolutionDegrees = metersToDegrees(resolutionMeters);

            points_original = [];
            for (let i = 0; i < polygonCoords.length; i++) {
              points_original.push([polygonCoords[i].lat, polygonCoords[i].lng])
            }
            const points_convex_hull = convexhull.makeHull(points_original);

            const bounds = L.polygon(polygonCoords).getBounds();
            const latStart = bounds.getNorthWest().lat;
            const latEnd = bounds.getSouthEast().lat - resolutionDegrees;
            const lngStart = bounds.getNorthWest().lng;
            const lngEnd = bounds.getSouthEast().lng + resolutionDegrees;

            const trajectory = [];
            let isLeftToRight = true; // Track the direction for horizontal movement

            // Create trajectory by scanning the area row by row
            for (let currentLat = latStart; currentLat > latEnd; currentLat -= resolutionDegrees) {
                if (isLeftToRight) {
                  for (let currentLng = lngStart; currentLng < lngEnd; currentLng += resolutionDegrees) {
                    let point = [currentLat, currentLng];
                    if (isPointInsidePolygen(point, points_convex_hull)) {
                      trajectory.push(point);
                    }
                  }
                } else {
                  for (let currentLng = lngEnd; currentLng > lngStart; currentLng -= resolutionDegrees) {
                    let point = [currentLat, currentLng];
                    if (isPointInsidePolygen(point, points_convex_hull)) {
                      trajectory.push(point);
                    }
                  }
                }
                isLeftToRight = !isLeftToRight; // Switch direction for the next row
            }
            return { points_convex_hull, trajectory };
        }

        // Handle polygon creation
        map.on(L.Draw.Event.CREATED, function (e) {
            if (trajectoryLayer) {
                map.removeLayer(trajectoryLayer);
            }

            const layer = e.layer;
            drawnItems.clearLayers();
            drawnItems.addLayer(layer);

            const polygonCoords = layer.getLatLngs()[0];
            const resolution = parseFloat(document.getElementById('resolution').value);

            const { convex_hull, trajectory } = createTrajectory(polygonCoords, resolution);

            // Draw trajectory
            trajectoryLayer = L.featureGroup();
            const polyline = L.polyline(trajectory, { color: 'blue' }).addTo(trajectoryLayer);

            // Highlight sampled points
            trajectory.forEach((point) => {
                L.circleMarker(point, {
                    radius: 5,
                    color: 'red',
                    fillColor: '#f03',
                    fillOpacity: 1
                }).addTo(trajectoryLayer);
            });

            trajectoryLayer.addTo(map);

            // Output trajectory details
            let output = 'Trajectory Points:<br>';
            trajectory.forEach((point, index) => {
                output += `Point ${index + 1}: ${point[0].toFixed(6)}, ${point[1].toFixed(6)}<br>`;
            });

            document.getElementById('output').innerHTML = output;
        });

        // Clear the map
        function clearMap() {
            drawnItems.clearLayers();
            if (trajectoryLayer) {
                map.removeLayer(trajectoryLayer);
                trajectoryLayer = null;
            }
            document.getElementById('output').innerHTML = 'Map cleared.';
        }
    </script>
</body>
</html>
