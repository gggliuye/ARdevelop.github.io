<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Polygon Selector with Trajectory</title>
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
    <!-- Leaflet Draw CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css" />
    <style>
        #map {
            height: 70vh;
            width: 100%;
        }
        #controls {
            padding: 10px;
            font-family: Arial, sans-serif;
        }
        #output {
            padding: 10px;
            font-family: Arial, sans-serif;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <h1>Polygon Selector with Trajectory</h1>

    <input type="file" id="xmlFileInput" accept=".xml,.kml"><br>
    <button onclick="extractCoordinates()">Read Coordinates</button>
    <div id="output"></div>

    <div id="controls">
        <label for="resolution">Trajectory Resolution (meters):</label>
        <input type="number" id="resolution" value="20" min="1">
        <button onclick="clearMap()">Clear Map</button>
    </div>
    <div id="map"></div>
    <div id="output_coord">Coordinates and trajectory details will be displayed here...</div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <!-- Leaflet Draw JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="math/convex_hull.js"></script>
    <script>
        const map = L.map('map', {
            zoomSnap: 0.05,
            zoomDelta: 0.25,
            zoomAnimation: true,
            wheelPxPerZoomLevel: 120,
            minZoom: 3
        }).fitWorld();

        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 20,
            attribution: 'Â© OpenStreetMap contributors'
        }).addTo(map);

        map.locate({ setView: true, maxZoom: 16 });

        const drawnItems = new L.FeatureGroup();
        map.addLayer(drawnItems);

        const drawControl = new L.Control.Draw({
            draw: {
                rectangle: true,
                polygon: true,
                polyline: false,
                circle: false,
                circlemarker: false,
                marker: false
            },
            edit: {
                featureGroup: drawnItems
            }
        });
        map.addControl(drawControl);

        let trajectoryLayer = null;

        // Convert resolution in meters to degrees
        function metersToDegrees(meters) {
            return meters / 111320; // Approximation for 1 degree = ~111.32 km
        }

        function isPointInsidePolygen(point, hull) {
            let count = 0;
            const [px, py] = point;
            for (let i = 0, j = hull.length - 1; i < hull.length; j = i++) {
                const [x1, y1] = hull[j];
                const [x2, y2] = hull[i];

                if ((y1 <= py && y2 > py || y2 <= py && y1 > py) &&
                    (x1 < (px - x2) * (y1 - y2) / (py - y2) + x2)) {
                    count++;
                }
            }
            return count % 2 !== 0; // If count is odd, the point is inside the hull
        }

        // Generate trajectory with 90-degree turns (scanning the area)
        function createTrajectory(polygonCoords, resolutionMeters) {
            const resolutionDegrees = metersToDegrees(resolutionMeters);

            points_original = [];
            for (let i = 0; i < polygonCoords.length; i++) {
              points_original.push([polygonCoords[i].lat, polygonCoords[i].lng])
            }
            const points_convex_hull = convexhull.makeHull(points_original);

            const bounds = L.polygon(polygonCoords).getBounds();
            const latStart = bounds.getNorthWest().lat;
            const latEnd = bounds.getSouthEast().lat - resolutionDegrees;
            const lngStart = bounds.getNorthWest().lng;
            const lngEnd = bounds.getSouthEast().lng + resolutionDegrees;

            const trajectory = [];
            let isLeftToRight = true; // Track the direction for horizontal movement

            // Create trajectory by scanning the area row by row
            for (let currentLat = latStart; currentLat > latEnd; currentLat -= resolutionDegrees) {
                if (isLeftToRight) {
                  for (let currentLng = lngStart; currentLng < lngEnd; currentLng += resolutionDegrees) {
                    let point = [currentLat, currentLng];
                    if (isPointInsidePolygen(point, points_convex_hull)) {
                      trajectory.push(point);
                    }
                  }
                } else {
                  for (let currentLng = lngEnd; currentLng > lngStart; currentLng -= resolutionDegrees) {
                    let point = [currentLat, currentLng];
                    if (isPointInsidePolygen(point, points_convex_hull)) {
                      trajectory.push(point);
                    }
                  }
                }
                isLeftToRight = !isLeftToRight; // Switch direction for the next row
            }
            return { points_convex_hull, trajectory };
        }

        // Handle polygon creation
        map.on(L.Draw.Event.CREATED, function (e) {
            if (trajectoryLayer) {
                map.removeLayer(trajectoryLayer);
            }

            const layer = e.layer;
            drawnItems.clearLayers();
            drawnItems.addLayer(layer);

            const polygonCoords = layer.getLatLngs()[0];
            const resolution = parseFloat(document.getElementById('resolution').value);

            const { convex_hull, trajectory } = createTrajectory(polygonCoords, resolution);

            // Draw trajectory
            trajectoryLayer = L.featureGroup();
            const polyline = L.polyline(trajectory, { color: 'blue' }).addTo(trajectoryLayer);

            // Highlight sampled points
            trajectory.forEach((point) => {
                L.circleMarker(point, {
                    radius: 5,
                    color: 'red',
                    fillColor: '#f03',
                    fillOpacity: 1
                }).addTo(trajectoryLayer);
            });

            trajectoryLayer.addTo(map);

            // Output trajectory details
            let output = 'Trajectory Points:<br>';
            trajectory.forEach((point, index) => {
                output += `Point ${index + 1}: ${point[0].toFixed(6)}, ${point[1].toFixed(6)}<br>`;
            });

            document.getElementById('output_coord').innerHTML = output;
        });

        // Clear the map
        function clearMap() {
            drawnItems.clearLayers();
            if (trajectoryLayer) {
                map.removeLayer(trajectoryLayer);
                trajectoryLayer = null;
            }
            markers.forEach(marker => {
                map.removeLayer(marker);
            });
            markers = []; // Reset markers array
            document.getElementById('output').innerHTML = 'Map cleared.';
        }

        let markers = []; // Array to store markers
        // Plot coordinates on the map and recenter to the first point
        function plotCoordinates(coordinatesList) {
            if (coordinatesList.length > 0) {
                const firstCoord = coordinatesList[0];
                const [firstLng, firstLat] = firstCoord.split(",").map(Number);

                if (!isNaN(firstLat) && !isNaN(firstLng)) {
                    map.setView([firstLat, firstLng], 18); // Recenter map to the first coordinate
                }

                coordinatesList.forEach(coord => {
                    const [lng, lat] = coord.split(",").map(Number); // WGS format is [lng, lat]
                    if (!isNaN(lat) && !isNaN(lng)) {
                        const marker = L.marker([lat, lng]).addTo(map);
                        markers.push(marker); // Store marker
                    }
                });
            }
        }

        // JavaScript to read and parse XML, extracting all coordinates from a user-uploaded file
        function extractCoordinates() {
            const fileInput = document.getElementById("xmlFileInput");
            const file = fileInput.files[0];

            if (!file) {
                document.getElementById("output").innerText = "Please upload an XML file.";
                return;
            }

            const reader = new FileReader();

            reader.onload = function(event) {
                const xmlData = event.target.result;

                try {
                    // Parse the XML data
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(xmlData, "text/xml");

                    // Check for parse errors
                    if (xmlDoc.getElementsByTagName("parsererror").length > 0) {
                        document.getElementById("output").innerText = "Error: Invalid XML file.";
                        return;
                    }

                    // Extract all <coordinates> elements' text content
                    const coordinatesElements = xmlDoc.getElementsByTagName("coordinates");
                    const coordinatesList = [];

                    for (let i = 0; i < coordinatesElements.length; i++) {
                        const content = coordinatesElements[i].textContent.trim();
                        coordinatesList.push(content);
                    }

                    // Display the results
                    if (coordinatesList.length > 0) {
                        document.getElementById("output").innerText = `Coordinates: \n${coordinatesList.join("\n")}`;
                        plotCoordinates(coordinatesList);
                    } else {
                        document.getElementById("output").innerText = "No <coordinates> elements found!";
                    }
                } catch (error) {
                    document.getElementById("output").innerText = "Error: Unable to process the file.";
                }
            };

            reader.readAsText(file);
        }
    </script>
</body>
</html>
